---
title: "Introduction to SMLN"
date: '`r Sys.Date()`'
author:
  - name: Nathan Constantine-Cooke
    email: nathan.constantine-cooke@ed.ac.uk
  - name: Catalina Vallejos
    email: catalina.vallejos@igmm.ed.ac.uk

output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2

vignette: >
  %\VignetteIndexEntry{SMLN}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Demonstration 

This vignette demonstrates how to use the `SMLN` package using the included `cancer` data-set from the veterans administration lung cancer trial. 

```{r setup}
library(SMLN)
``` 

```{r}
n <- dim(cancer)[1]
```

## Building the Design Matrix

```{r}
Intercept <- rep(1, times = n) # Intercept
x1 <- rep(0, times = n) # Treat (1 dummy variable) 
for(i in 1 : n) {if(cancer$treat[i] == 2) x1[i] <- 1}

# Type (3 dummy variables)
x2 <- rep(0, times = n)
x3 <- rep(0, times = n)
x4 <- rep(0, times = n)

for(i in 1 : n) {if(cancer$type[i] == 1) x2[i] <- 1 
if(cancer$type[i] == 2) x3[i] <- 1
if(cancer$type[i] == 3) x4[i] <- 1}
x5 <- cancer$status # Status 
x6 <- cancer$mfd # Moths from diagnosis
x7 <- cancer$age # Age
x8 <- rep(0, times = n) # Prior (Dummy variable) 
for(i in 1 : n) {if(cancer$prior[i] == 10) x8[i] <- 1}
X <- cbind(Intercept, x1, x2, x3, x4, x5, x6, x7, x8)
Time <- cancer$time; Cens <- cancer$censor
```


### Starting values

Set random starting values

```{r}
beta0 <- rnorm(9, 0, 1)
sigma20 <- rgamma(1, 2, 2)
nu0 <- rgamma(1, 2, 2)
alpha0 <- runif(1, 1, 2)
```


## MCMC chains 

Please note: N=1000 is not enough to reach convergence. This is only an illustration. Run longer chains for more accurate estimations (especially for the log-exponential power model).

```{r}
system.time(LN <- MCMC_LN(N = 1000, thin = 20, Time, Cens, X, beta0, sigma20, 
                          prior = 2, set = 1, eps_l = 0.5, eps_r = 0.5))
system.time(LST <- MCMC_LST(N = 1000, thin = 20, Q = 1, Time, Cens, X, beta0,
                            sigma20, nu0, prior = 2, set = 1, eps_l = 0.5,
                            eps_r = 0.5, ar = 0.44))
system.time(LLAP <- MCMC_LLAP(N = 1000, thin = 20,  Q = 1, Time, Cens, X, beta0,
                              sigma20, prior = 2, set = 1, eps_l = 0.5,
                              eps_r = 0.5))
system.time(LEP <- MCMC_LEP(N = 1000, thin = 20, Time, Cens, X, beta0, sigma20, 
                            alpha0, prior = 2, set = 1, eps_l = 0.5,
                            eps_r = 0.5, ar = 0.44))
system.time(LLOG <- MCMC_LLOG(N = 1000, thin = 20, Q = 10, Time, Cens, X,
                              beta0, sigma20, prior = 2, set = 1, N.AKS = 3))
```
## Removing the BURN-IN PERIOD
```{r}
burn <- 1 : 11
LN.B <- LN[-burn, ]
LST.B <- LST[-burn, ]
LLAP.B <- LLAP[-burn, ]
LEP.B <- LEP[-burn, ] 
LLOG.B <- LLOG[-burn, ]
```



## Deviance information criteria 
```{r}
DIC_LN(Time, Cens, X, chain = LN.B, set = 1, eps_l = 0.5, eps_r = 0.5)
DIC_LST(Time, Cens, X, chain = LST.B, set = 1, eps_l = 0.5, eps_r = 0.5)
DIC_LLAP(Time, Cens, X, chain = LLAP.B, set = 1, eps_l = 0.5, eps_r = 0.5)
DIC_LEP(Time, Cens, X, chain = LEP.B, set = 1, eps_l = 0.5, eps_r = 0.5)
DIC_LLOG(Time, Cens, X, chain = LLOG.B, set = 1, eps_l = 0.5, eps_r = 0.5)
```


## LOG-MARGINAL LIKELIHOOD
```{r}
LML_LN(thin = 20, Time, Cens, X, chain = LN.B, prior = 2, set = 1, eps_l = 0.5,
       eps_r = 0.5) 
LML_LST(thin = 20, Q = 1, Time, Cens, X, chain = LST.B, prior = 2, set = 1,
        eps_l = 0.5, eps_r = 0.5) 
LML_LLAP(thin = 20, Q = 1, Time, Cens, X, chain = LLAP.B, prior = 2, set = 1,
         eps_l = 0.5, eps_r = 0.5) 
LML_LEP(thin = 20, Time, Cens, X, chain = LEP.B, prior = 2, set = 1,
        eps_l = 0.5, eps_r = 0.5) 
LML_LLOG(thin = 20, Q = 10, Time, Cens, X, chain = LLOG.B, prior = 2, set = 1,
         eps_l = 0.5, eps_r = 0.5, N.AKS = 3) 
```


## CPO, KL and calibration 
```{r}
CaseDeletion_LN(Time, Cens, X, chain = LN.B, set = 1, eps_l = 0.5, eps_r = 0.5)
CaseDeletion_LST(Time, Cens, X, chain = LST.B, set = 1, eps_l = 0.5,
                 eps_r = 0.5)
CaseDeletion_LLAP(Time,Cens, X, chain = LLAP.B, set = 1, eps_l = 0.5,
                  eps_r = 0.5)
CaseDeletion_LEP(Time,Cens,X,chain = LEP.B, set = 1,eps_l = 0.5, eps_r = 0.5)
CaseDeletion_LLOG(Time, Cens, X, chain = LLOG.B, set = 1, eps_l = 0.5,
                  eps_r = 0.5)
```


## Outlier detection
```{r}
OD.LST <- rep(0, n)
OD.LLAP <- rep(0, n)
OD.LLOG <- rep(0, n) 
OD.LEP <- rep(0, n)
for(i in 1 : n)
{
	OD.LST[i] <- BF_lambda_obs_LST(N = 100, thin = 20, Q = 1 , burn = 1, ref = 1,
	                               obs = i, Time, Cens, X, chain = LST.B, 
	                               prior = 2, set = 1, eps_l = 0.5, eps_r = 0.5,
	                               ar = 0.44)
	print(i)
}
for(i in 1 : n)
{
	OD.LLAP[i] <- BF_lambda_obs_LLAP(i, ref = 1, X, chain = LLAP.B)
	print(i)
}
for(i in 1 : n)
{
	OD.LLOG[i] <- BF_lambda_obs_LLOG(i, ref = 0.4, X, chain = LLAP.B)
	print(i)
}
alpha <- median(LEP.B[,11])
uref <- 1 + 1 / alpha + 0.6
uref

for(i in 1:n)
{
	OD.LEP[i] < -BF_u_obs_LEP(N = 100, thin = 20, burn =1 , ref = uref, obs = i,
	                          Time, Cens, X, chain = LEP.B, prior = 2, set = 1,
	                          eps_l = 0.5, eps_r = 0.5, ar = 0.44)
	print(i)
}
```
